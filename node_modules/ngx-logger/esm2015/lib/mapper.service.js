/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
export class NGXMapperService {
    /**
     * @param {?} httpBackend
     */
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // used to cache source maps
        this.logPositionRequests = new Map();
    }
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    static getStackLine() {
        /** @type {?} */
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        const positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        let positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getTranspileLocation(stackLine) {
        /** @type {?} */
        let locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf(' ');
        }
        /** @type {?} */
        let locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getMapFilePath(stackLine) {
        /** @type {?} */
        const file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        let sourceFileIndex = 0;
        /** @type {?} */
        let // second field
        sourceCodeLine = 0;
        /** @type {?} */
        let // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            let generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                const decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        /** @type {?} */
        const req = new HttpRequest('GET', sourceMapLocation);
        if (!this.logPositionRequests.has(sourceMapLocation)) {
            /** @type {?} */
            const logPosition = this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            e => (e instanceof HttpResponse))), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            (httpResponse) => httpResponse.body)), map((/**
             * @param {?} sourceMap
             * @return {?}
             */
            sourceMap => {
                // map generated position to source position
                return NGXMapperService.getMapping(sourceMap, distPosition);
            })), retry(3), 
            // if there is an error getting the source, map fall back to the filename and line number of
            catchError((/**
             * @return {?}
             */
            () => {
                return of(distPosition);
            })), shareReplay(1));
            this.logPositionRequests.set(sourceMapLocation, logPosition);
        }
        return this.logPositionRequests.get(sourceMapLocation);
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    getCallerDetails(sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        // parse generated file mapping from stack trace
        /** @type {?} */
        const stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        })));
    }
}
NGXMapperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.logPositionRequests;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQzVFLE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBQzNCLE9BQU8sRUFBYSxFQUFFLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEYsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBR2pELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7SUFLM0IsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7O1FBRnBDLHdCQUFtQixHQUF5QyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBRzlFLENBQUM7Ozs7Ozs7O0lBS08sTUFBTSxDQUFDLFlBQVk7O2NBQ25CLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRTtRQUV6QixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUVWLElBQUk7Z0JBQ0YsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjtJQUNILENBQUM7Ozs7OztJQUVPLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBaUI7OztjQUVwQyxrQkFBa0Is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QyxDQUFDO2FBQ3pCO1lBRUQsNERBQTREO1lBQzVELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUM3RCxDQUFDLEVBQUMsQ0FDSCxDQUFDO0lBR0osQ0FBQzs7O1lBektGLFVBQVU7Ozs7WUFOSCxXQUFXOzs7Ozs7O0lBVWpCLCtDQUE4RTs7Ozs7SUFFbEUsdUNBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTb3VyY2VNYXB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0h0dHBCYWNrZW5kLCBIdHRwUmVxdWVzdCwgSHR0cFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgKiBhcyB2bHEgZnJvbSAndmxxJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcCwgcmV0cnksIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7TG9nUG9zaXRpb259IGZyb20gJy4vdHlwZXMvbG9nLXBvc2l0aW9uJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5HWE1hcHBlclNlcnZpY2Uge1xuXG4gIC8vIHVzZWQgdG8gY2FjaGUgc291cmNlIG1hcHNcbiAgcHJpdmF0ZSBsb2dQb3NpdGlvblJlcXVlc3RzOiBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPj4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwQmFja2VuZDogSHR0cEJhY2tlbmQpIHtcbiAgfVxuXG4gIC8qXG4gIFN0YXRpYyBGdW5jdGlvbnNcbiAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRTdGFja0xpbmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIG5vaW5zcGVjdGlvbiBFeGNlcHRpb25DYXVnaHRMb2NhbGx5SlNcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKVs1XTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0UG9zaXRpb24oc3RhY2tMaW5lOiBzdHJpbmcpOiBMb2dQb3NpdGlvbiB7XG4gICAgLy8gc3RyaXAgYmFzZSBwYXRoLCB0aGVuIHBhcnNlIGZpbGVuYW1lLCBsaW5lLCBhbmQgY29sdW1uXG4gICAgY29uc3QgcG9zaXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmxhc3RJbmRleE9mKCdcXC8nKTtcbiAgICBsZXQgcG9zaXRpb25FbmRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcpJyk7XG4gICAgaWYgKHBvc2l0aW9uRW5kSW5kZXggPCAwKSB7XG4gICAgICBwb3NpdGlvbkVuZEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc2l0aW9uID0gc3RhY2tMaW5lLnN1YnN0cmluZyhwb3NpdGlvblN0YXJ0SW5kZXggKyAxLCBwb3NpdGlvbkVuZEluZGV4KTtcbiAgICBjb25zdCBkYXRhQXJyYXkgPSBwb3NpdGlvbi5zcGxpdCgnOicpO1xuICAgIGlmIChkYXRhQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKGRhdGFBcnJheVswXSwgK2RhdGFBcnJheVsxXSwgK2RhdGFBcnJheVsyXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgbG9jYXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJygnKTtcbiAgICBpZiAobG9jYXRpb25TdGFydEluZGV4IDwgMCkge1xuICAgICAgbG9jYXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmxhc3RJbmRleE9mKCcgJyk7XG4gICAgfVxuXG4gICAgbGV0IGxvY2F0aW9uRW5kSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKScpO1xuICAgIGlmIChsb2NhdGlvbkVuZEluZGV4IDwgMCkge1xuICAgICAgbG9jYXRpb25FbmRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tMaW5lLnN1YnN0cmluZyhsb2NhdGlvblN0YXJ0SW5kZXggKyAxLCBsb2NhdGlvbkVuZEluZGV4KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcEZpbGVQYXRoKHN0YWNrTGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBmaWxlID0gTkdYTWFwcGVyU2VydmljZS5nZXRUcmFuc3BpbGVMb2NhdGlvbihzdGFja0xpbmUpO1xuICAgIGNvbnN0IG1hcEZ1bGxQYXRoID0gZmlsZS5zdWJzdHJpbmcoMCwgZmlsZS5sYXN0SW5kZXhPZignOicpKTtcbiAgICByZXR1cm4gbWFwRnVsbFBhdGguc3Vic3RyaW5nKDAsIG1hcEZ1bGxQYXRoLmxhc3RJbmRleE9mKCc6JykpICsgJy5tYXAnO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWFwcGluZyhzb3VyY2VNYXA6IFNvdXJjZU1hcCwgcG9zaXRpb246IExvZ1Bvc2l0aW9uKTogTG9nUG9zaXRpb24ge1xuICAgIC8vID0+ICc7JyBpbmRpY2F0ZXMgZW5kIG9mIGEgbGluZVxuICAgIC8vID0+ICcsJyBzZXBhcmF0ZXMgbWFwcGluZ3MgaW4gYSBsaW5lXG4gICAgLy8gZGVjb2RlZCBtYXBwaW5nID0+IFsgZ2VuZXJhdGVkQ29kZUNvbHVtbiwgc291cmNlRmlsZUluZGV4LCBzb3VyY2VDb2RlTGluZSwgc291cmNlQ29kZUNvbHVtbiwgbmFtZUluZGV4IF1cbiAgICBsZXQgc291cmNlRmlsZUluZGV4ID0gMCwgICAvLyBzZWNvbmQgZmllbGRcbiAgICAgIHNvdXJjZUNvZGVMaW5lID0gMCwgICAgLy8gdGhpcmQgZmllbGRcbiAgICAgIHNvdXJjZUNvZGVDb2x1bW4gPSAwOyAgLy8gZm91cnRoIGZpZWxkXG5cbiAgICBjb25zdCBsaW5lcyA9IHNvdXJjZU1hcC5tYXBwaW5ncy5zcGxpdCgnOycpO1xuXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xuICAgICAgLy8gcmVzZXQgY29sdW1uIHBvc2l0aW9uIHRvIDAgYWZ0ZXIgZWFjaCBsaW5lXG4gICAgICBsZXQgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7XG4gICAgICAvLyBkZWNvZGUgc2VjdGlvbnMgaW4gbGluZVxuICAgICAgY29uc3QgY29sdW1ucyA9IGxpbmVzW2xpbmVJbmRleF0uc3BsaXQoJywnKTtcblxuICAgICAgZm9yIChsZXQgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGNvbHVtbnMubGVuZ3RoOyBjb2x1bW5JbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRTZWN0aW9uID0gdmxxLmRlY29kZShjb2x1bW5zW2NvbHVtbkluZGV4XSk7XG4gICAgICAgIGlmIChkZWNvZGVkU2VjdGlvbi5sZW5ndGggPj0gNCkge1xuICAgICAgICAgIC8vIHVwZGF0ZSByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IGRlY29kZWRTZWN0aW9uWzBdO1xuICAgICAgICAgIHNvdXJjZUZpbGVJbmRleCArPSBkZWNvZGVkU2VjdGlvblsxXTtcbiAgICAgICAgICBzb3VyY2VDb2RlTGluZSArPSBkZWNvZGVkU2VjdGlvblsyXTtcbiAgICAgICAgICBzb3VyY2VDb2RlQ29sdW1uICs9IGRlY29kZWRTZWN0aW9uWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbWF0Y2hpbmcgbWFwXG4gICAgICAgIGlmIChsaW5lSW5kZXggPT09IHBvc2l0aW9uLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICBpZiAoZ2VuZXJhdGVkQ29kZUNvbHVtbiA9PT0gcG9zaXRpb24uY29sdW1uTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBtYXRjaGluZyBjb2x1bW4gYW5kIGxpbmUgZm91bmRcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uSW5kZXggKyAxID09PSBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY29sdW1uIG5vdCBmb3VuZCwgYnV0IGxpbmUgaXMgY29ycmVjdFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihzb3VyY2VNYXAuc291cmNlc1tzb3VyY2VGaWxlSW5kZXhdLCBzb3VyY2VDb2RlTGluZSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZhaWxlZCBpZiByZWFjaGVkXG4gICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbigndW5rbm93bicsIDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIGRvZXMgdGhlIGh0dHAgZ2V0IHJlcXVlc3QgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwXG4gICAqIEBwYXJhbSBzb3VyY2VNYXBMb2NhdGlvblxuICAgKiBAcGFyYW0gZGlzdFBvc2l0aW9uXG4gICAqL1xuICBwcml2YXRlIF9nZXRTb3VyY2VNYXAoc291cmNlTWFwTG9jYXRpb246IHN0cmluZywgZGlzdFBvc2l0aW9uOiBMb2dQb3NpdGlvbik6IE9ic2VydmFibGU8TG9nUG9zaXRpb24+IHtcbiAgICBjb25zdCByZXEgPSBuZXcgSHR0cFJlcXVlc3Q8U291cmNlTWFwPignR0VUJywgc291cmNlTWFwTG9jYXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmxvZ1Bvc2l0aW9uUmVxdWVzdHMuaGFzKHNvdXJjZU1hcExvY2F0aW9uKSkge1xuICAgICAgY29uc3QgbG9nUG9zaXRpb24gPSB0aGlzLmh0dHBCYWNrZW5kLmhhbmRsZShyZXEpLnBpcGUoXG4gICAgICAgIGZpbHRlcihlID0+IChlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSksXG4gICAgICAgIG1hcDxIdHRwUmVzcG9uc2U8U291cmNlTWFwPiwgU291cmNlTWFwPigoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8U291cmNlTWFwPikgPT4gaHR0cFJlc3BvbnNlLmJvZHkpLFxuICAgICAgICBtYXA8U291cmNlTWFwLCBMb2dQb3NpdGlvbj4oc291cmNlTWFwID0+IHtcbiAgICAgICAgICAvLyBtYXAgZ2VuZXJhdGVkIHBvc2l0aW9uIHRvIHNvdXJjZSBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcHBpbmcoc291cmNlTWFwLCBkaXN0UG9zaXRpb24pO1xuICAgICAgICB9KSxcbiAgICAgICAgcmV0cnkoMyksXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGVycm9yIGdldHRpbmcgdGhlIHNvdXJjZSwgbWFwIGZhbGwgYmFjayB0byB0aGUgZmlsZW5hbWUgYW5kIGxpbmUgbnVtYmVyIG9mXG4gICAgICAgIGNhdGNoRXJyb3IoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvZihkaXN0UG9zaXRpb24pO1xuICAgICAgICB9KSxcbiAgICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICAgICk7XG4gICAgICB0aGlzLmxvZ1Bvc2l0aW9uUmVxdWVzdHMuc2V0KHNvdXJjZU1hcExvY2F0aW9uLCBsb2dQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9nUG9zaXRpb25SZXF1ZXN0cy5nZXQoc291cmNlTWFwTG9jYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIExvZ1Bvc2l0aW9uIGZvciB0aGUgY3VycmVudCBsb2dcbiAgICogSWYgc291cmNlTWFwcyBhcmUgZW5hYmxlZCwgaXQgYXR0ZW1wcyB0byBnZXQgdGhlIHNvdXJjZSBtYXAgZnJvbSB0aGUgc2VydmVyLCBhbmQgdXNlIHRoYXQgdG8gcGFyc2UgdGhlIGZpbGUgbmFtZVxuICAgKiBhbmQgbnVtYmVyIG9mIHRoZSBjYWxsXG4gICAqIEBwYXJhbSBzb3VyY2VNYXBzRW5hYmxlZFxuICAgKi9cbiAgcHVibGljIGdldENhbGxlckRldGFpbHMoc291cmNlTWFwc0VuYWJsZWQ6IGJvb2xlYW4pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgLy8gcGFyc2UgZ2VuZXJhdGVkIGZpbGUgbWFwcGluZyBmcm9tIHN0YWNrIHRyYWNlXG5cbiAgICBjb25zdCBzdGFja0xpbmUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFN0YWNrTGluZSgpO1xuXG4gICAgLy8gaWYgd2Ugd2VyZSBub3QgYWJsZSB0byBwYXJzZSB0aGUgc3RhY2tMaW5lLCBqdXN0IHJldHVybiBhbiBlbXB0eSBMb2cgUG9zaXRpb25cbiAgICBpZiAoIXN0YWNrTGluZSkge1xuICAgICAgcmV0dXJuIG9mKG5ldyBMb2dQb3NpdGlvbignJywgMCwgMCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvZihbXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldFBvc2l0aW9uKHN0YWNrTGluZSksXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcEZpbGVQYXRoKHN0YWNrTGluZSlcbiAgICBdKS5waXBlKFxuICAgICAgc3dpdGNoTWFwPFtMb2dQb3NpdGlvbiwgc3RyaW5nXSwgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+KChbZGlzdFBvc2l0aW9uLCBzb3VyY2VNYXBMb2NhdGlvbl0pID0+IHtcblxuICAgICAgICAvLyBpZiBzb3VyY2UgbWFwcyBhcmUgbm90IGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIHByZXZpb3VzbHkgdHJpZWQgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwcywgYnV0IHRoZXkgZmFpbGVkLFxuICAgICAgICAvLyB0aGVuIGp1c3QgdXNlIHRoZSBwb3NpdGlvbiBvZiB0aGUgSlMgaW5zdGVhZCBvZiB0aGUgc291cmNlXG4gICAgICAgIGlmICghc291cmNlTWFwc0VuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgdHJ5IHRvIGdldCB0aGUgc291cmNlIG1hcCBhbmQgcmV0dXJuIHRoZSBwb3NpdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uLCBkaXN0UG9zaXRpb24pO1xuICAgICAgfSlcbiAgICApO1xuXG5cbiAgfVxufVxuXG5cblxuXG4iXX0=