/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
var NGXMapperService = /** @class */ (function () {
    function NGXMapperService(httpBackend) {
        this.httpBackend = httpBackend;
        // used to cache source maps
        this.logPositionRequests = new Map();
    }
    /*
    Static Functions
   */
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    NGXMapperService.getStackLine = /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getPosition = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        var positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        var positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        var position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        var dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getTranspileLocation = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf(' ');
        }
        /** @type {?} */
        var locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getMapFilePath = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        var mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    };
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    NGXMapperService.getMapping = /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    function (sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        var sourceFileIndex = 0;
        /** @type {?} */
        var // second field
        sourceCodeLine = 0;
        /** @type {?} */
        var // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        var lines = sourceMap.mappings.split(';');
        for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            var generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            var columns = lines[lineIndex].split(',');
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                var decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    NGXMapperService.prototype._getSourceMap = /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    function (sourceMapLocation, distPosition) {
        /** @type {?} */
        var req = new HttpRequest('GET', sourceMapLocation);
        if (!this.logPositionRequests.has(sourceMapLocation)) {
            /** @type {?} */
            var logPosition = this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return (e instanceof HttpResponse); })), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            function (httpResponse) { return httpResponse.body; })), map((/**
             * @param {?} sourceMap
             * @return {?}
             */
            function (sourceMap) {
                // map generated position to source position
                return NGXMapperService.getMapping(sourceMap, distPosition);
            })), retry(3), 
            // if there is an error getting the source, map fall back to the filename and line number of
            catchError((/**
             * @return {?}
             */
            function () {
                return of(distPosition);
            })), shareReplay(1));
            this.logPositionRequests.set(sourceMapLocation, logPosition);
        }
        return this.logPositionRequests.get(sourceMapLocation);
    };
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     */
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    NGXMapperService.prototype.getCallerDetails = /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    function (sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        var _this = this;
        // parse generated file mapping from stack trace
        /** @type {?} */
        var stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return _this._getSourceMap(sourceMapLocation, distPosition);
        })));
    };
    NGXMapperService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NGXMapperService.ctorParameters = function () { return [
        { type: HttpBackend }
    ]; };
    return NGXMapperService;
}());
export { NGXMapperService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.logPositionRequests;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RSxPQUFPLEtBQUssR0FBRyxNQUFNLEtBQUssQ0FBQztBQUMzQixPQUFPLEVBQWEsRUFBRSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUVqRDtJQU1FLDBCQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTs7UUFGcEMsd0JBQW1CLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7SUFHOUUsQ0FBQztJQUVEOztLQUVDOzs7Ozs7OztJQUNjLDZCQUFZOzs7Ozs7O0lBQTNCOztZQUNRLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRTtRQUV6QixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUVWLElBQUk7Z0JBQ0YsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjtJQUNILENBQUM7Ozs7OztJQUVjLDRCQUFXOzs7OztJQUExQixVQUEyQixTQUFpQjs7O1lBRXBDLGtCQUFrQixHQUFH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Rix3R0FBd0c7WUFDeEcsNkRBQTZEO1lBQzdELElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDekI7WUFFRCw0REFBNEQ7WUFDNUQsT0FBTyxLQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzdELENBQUMsRUFBQyxDQUNILENBQUM7SUFHSixDQUFDOztnQkF6S0YsVUFBVTs7OztnQkFOSCxXQUFXOztJQWdMbkIsdUJBQUM7Q0FBQSxBQTFLRCxJQTBLQztTQXpLWSxnQkFBZ0I7Ozs7OztJQUczQiwrQ0FBOEU7Ozs7O0lBRWxFLHVDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U291cmNlTWFwfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIdHRwQmFja2VuZCwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0ICogYXMgdmxxIGZyb20gJ3ZscSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7Y2F0Y2hFcnJvciwgZmlsdGVyLCBtYXAsIHJldHJ5LCBzaGFyZVJlcGxheSwgc3dpdGNoTWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0xvZ1Bvc2l0aW9ufSBmcm9tICcuL3R5cGVzL2xvZy1wb3NpdGlvbic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOR1hNYXBwZXJTZXJ2aWNlIHtcblxuICAvLyB1c2VkIHRvIGNhY2hlIHNvdXJjZSBtYXBzXG4gIHByaXZhdGUgbG9nUG9zaXRpb25SZXF1ZXN0czogTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cEJhY2tlbmQ6IEh0dHBCYWNrZW5kKSB7XG4gIH1cblxuICAvKlxuICBTdGF0aWMgRnVuY3Rpb25zXG4gKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhY2tMaW5lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJylbNV07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFBvc2l0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogTG9nUG9zaXRpb24ge1xuICAgIC8vIHN0cmlwIGJhc2UgcGF0aCwgdGhlbiBwYXJzZSBmaWxlbmFtZSwgbGluZSwgYW5kIGNvbHVtblxuICAgIGNvbnN0IHBvc2l0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignXFwvJyk7XG4gICAgbGV0IHBvc2l0aW9uRW5kSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKScpO1xuICAgIGlmIChwb3NpdGlvbkVuZEluZGV4IDwgMCkge1xuICAgICAgcG9zaXRpb25FbmRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHN0YWNrTGluZS5zdWJzdHJpbmcocG9zaXRpb25TdGFydEluZGV4ICsgMSwgcG9zaXRpb25FbmRJbmRleCk7XG4gICAgY29uc3QgZGF0YUFycmF5ID0gcG9zaXRpb24uc3BsaXQoJzonKTtcbiAgICBpZiAoZGF0YUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihkYXRhQXJyYXlbMF0sICtkYXRhQXJyYXlbMV0sICtkYXRhQXJyYXlbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKCd1bmtub3duJywgMCwgMCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUcmFuc3BpbGVMb2NhdGlvbihzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcoJyk7XG4gICAgaWYgKGxvY2F0aW9uU3RhcnRJbmRleCA8IDApIHtcbiAgICAgIGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignICcpO1xuICAgIH1cblxuICAgIGxldCBsb2NhdGlvbkVuZEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJyknKTtcbiAgICBpZiAobG9jYXRpb25FbmRJbmRleCA8IDApIHtcbiAgICAgIGxvY2F0aW9uRW5kSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrTGluZS5zdWJzdHJpbmcobG9jYXRpb25TdGFydEluZGV4ICsgMSwgbG9jYXRpb25FbmRJbmRleCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBGaWxlUGF0aChzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IE5HWE1hcHBlclNlcnZpY2UuZ2V0VHJhbnNwaWxlTG9jYXRpb24oc3RhY2tMaW5lKTtcbiAgICBjb25zdCBtYXBGdWxsUGF0aCA9IGZpbGUuc3Vic3RyaW5nKDAsIGZpbGUubGFzdEluZGV4T2YoJzonKSk7XG4gICAgcmV0dXJuIG1hcEZ1bGxQYXRoLnN1YnN0cmluZygwLCBtYXBGdWxsUGF0aC5sYXN0SW5kZXhPZignOicpKSArICcubWFwJztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcHBpbmcoc291cmNlTWFwOiBTb3VyY2VNYXAsIHBvc2l0aW9uOiBMb2dQb3NpdGlvbik6IExvZ1Bvc2l0aW9uIHtcbiAgICAvLyA9PiAnOycgaW5kaWNhdGVzIGVuZCBvZiBhIGxpbmVcbiAgICAvLyA9PiAnLCcgc2VwYXJhdGVzIG1hcHBpbmdzIGluIGEgbGluZVxuICAgIC8vIGRlY29kZWQgbWFwcGluZyA9PiBbIGdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUZpbGVJbmRleCwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4sIG5hbWVJbmRleCBdXG4gICAgbGV0IHNvdXJjZUZpbGVJbmRleCA9IDAsICAgLy8gc2Vjb25kIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlTGluZSA9IDAsICAgIC8vIHRoaXJkIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlQ29sdW1uID0gMDsgIC8vIGZvdXJ0aCBmaWVsZFxuXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2VNYXAubWFwcGluZ3Muc3BsaXQoJzsnKTtcblxuICAgIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICAgIC8vIHJlc2V0IGNvbHVtbiBwb3NpdGlvbiB0byAwIGFmdGVyIGVhY2ggbGluZVxuICAgICAgbGV0IGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgLy8gZGVjb2RlIHNlY3Rpb25zIGluIGxpbmVcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBsaW5lc1tsaW5lSW5kZXhdLnNwbGl0KCcsJyk7XG5cbiAgICAgIGZvciAobGV0IGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjb2x1bW5zLmxlbmd0aDsgY29sdW1uSW5kZXgrKykge1xuICAgICAgICBjb25zdCBkZWNvZGVkU2VjdGlvbiA9IHZscS5kZWNvZGUoY29sdW1uc1tjb2x1bW5JbmRleF0pO1xuICAgICAgICBpZiAoZGVjb2RlZFNlY3Rpb24ubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblswXTtcbiAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggKz0gZGVjb2RlZFNlY3Rpb25bMV07XG4gICAgICAgICAgc291cmNlQ29kZUxpbmUgKz0gZGVjb2RlZFNlY3Rpb25bMl07XG4gICAgICAgICAgc291cmNlQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIG1hdGNoaW5nIG1hcFxuICAgICAgICBpZiAobGluZUluZGV4ID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGdlbmVyYXRlZENvZGVDb2x1bW4gPT09IHBvc2l0aW9uLmNvbHVtbk51bWJlcikge1xuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY29sdW1uIGFuZCBsaW5lIGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbkluZGV4ICsgMSA9PT0gY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBub3QgZm91bmQsIGJ1dCBsaW5lIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBmYWlsZWQgaWYgcmVhY2hlZFxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkb2VzIHRoZSBodHRwIGdldCByZXF1ZXN0IHRvIGdldCB0aGUgc291cmNlIG1hcFxuICAgKiBAcGFyYW0gc291cmNlTWFwTG9jYXRpb25cbiAgICogQHBhcmFtIGRpc3RQb3NpdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uOiBzdHJpbmcsIGRpc3RQb3NpdGlvbjogTG9nUG9zaXRpb24pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgY29uc3QgcmVxID0gbmV3IEh0dHBSZXF1ZXN0PFNvdXJjZU1hcD4oJ0dFVCcsIHNvdXJjZU1hcExvY2F0aW9uKTtcblxuICAgIGlmICghdGhpcy5sb2dQb3NpdGlvblJlcXVlc3RzLmhhcyhzb3VyY2VNYXBMb2NhdGlvbikpIHtcbiAgICAgIGNvbnN0IGxvZ1Bvc2l0aW9uID0gdGhpcy5odHRwQmFja2VuZC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgICBmaWx0ZXIoZSA9PiAoZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkpLFxuICAgICAgICBtYXA8SHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4sIFNvdXJjZU1hcD4oKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4pID0+IGh0dHBSZXNwb25zZS5ib2R5KSxcbiAgICAgICAgbWFwPFNvdXJjZU1hcCwgTG9nUG9zaXRpb24+KHNvdXJjZU1hcCA9PiB7XG4gICAgICAgICAgLy8gbWFwIGdlbmVyYXRlZCBwb3NpdGlvbiB0byBzb3VyY2UgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gTkdYTWFwcGVyU2VydmljZS5nZXRNYXBwaW5nKHNvdXJjZU1hcCwgZGlzdFBvc2l0aW9uKTtcbiAgICAgICAgfSksXG4gICAgICAgIHJldHJ5KDMpLFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBlcnJvciBnZXR0aW5nIHRoZSBzb3VyY2UsIG1hcCBmYWxsIGJhY2sgdG8gdGhlIGZpbGVuYW1lIGFuZCBsaW5lIG51bWJlciBvZlxuICAgICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcbiAgICAgICAgfSksXG4gICAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgICApO1xuICAgICAgdGhpcy5sb2dQb3NpdGlvblJlcXVlc3RzLnNldChzb3VyY2VNYXBMb2NhdGlvbiwgbG9nUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvZ1Bvc2l0aW9uUmVxdWVzdHMuZ2V0KHNvdXJjZU1hcExvY2F0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb2dQb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nXG4gICAqIElmIHNvdXJjZU1hcHMgYXJlIGVuYWJsZWQsIGl0IGF0dGVtcHMgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwIGZyb20gdGhlIHNlcnZlciwgYW5kIHVzZSB0aGF0IHRvIHBhcnNlIHRoZSBmaWxlIG5hbWVcbiAgICogYW5kIG51bWJlciBvZiB0aGUgY2FsbFxuICAgKiBAcGFyYW0gc291cmNlTWFwc0VuYWJsZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDYWxsZXJEZXRhaWxzKHNvdXJjZU1hcHNFbmFibGVkOiBib29sZWFuKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xuICAgIC8vIHBhcnNlIGdlbmVyYXRlZCBmaWxlIG1hcHBpbmcgZnJvbSBzdGFjayB0cmFjZVxuXG4gICAgY29uc3Qgc3RhY2tMaW5lID0gTkdYTWFwcGVyU2VydmljZS5nZXRTdGFja0xpbmUoKTtcblxuICAgIC8vIGlmIHdlIHdlcmUgbm90IGFibGUgdG8gcGFyc2UgdGhlIHN0YWNrTGluZSwganVzdCByZXR1cm4gYW4gZW1wdHkgTG9nIFBvc2l0aW9uXG4gICAgaWYgKCFzdGFja0xpbmUpIHtcbiAgICAgIHJldHVybiBvZihuZXcgTG9nUG9zaXRpb24oJycsIDAsIDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2YoW1xuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRQb3NpdGlvbihzdGFja0xpbmUpLFxuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBGaWxlUGF0aChzdGFja0xpbmUpXG4gICAgXSkucGlwZShcbiAgICAgIHN3aXRjaE1hcDxbTG9nUG9zaXRpb24sIHN0cmluZ10sIE9ic2VydmFibGU8TG9nUG9zaXRpb24+PigoW2Rpc3RQb3NpdGlvbiwgc291cmNlTWFwTG9jYXRpb25dKSA9PiB7XG5cbiAgICAgICAgLy8gaWYgc291cmNlIG1hcHMgYXJlIG5vdCBlbmFibGVkLCBvciBpZiB3ZSd2ZSBwcmV2aW91c2x5IHRyaWVkIHRvIGdldCB0aGUgc291cmNlIG1hcHMsIGJ1dCB0aGV5IGZhaWxlZCxcbiAgICAgICAgLy8gdGhlbiBqdXN0IHVzZSB0aGUgcG9zaXRpb24gb2YgdGhlIEpTIGluc3RlYWQgb2YgdGhlIHNvdXJjZVxuICAgICAgICBpZiAoIXNvdXJjZU1hcHNFbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGRpc3RQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHRyeSB0byBnZXQgdGhlIHNvdXJjZSBtYXAgYW5kIHJldHVybiB0aGUgcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbiwgZGlzdFBvc2l0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcblxuXG4gIH1cbn1cblxuXG5cblxuIl19